Packed and obfuscated codes often inlcudes LoadLibrary and GetProcAddress
linking: Static, Dynamic, Runtime
no need to include a library in header of file: LoadLibrary , GetProcAddress, LdrGetProcAddress, LdrLoadDll
LoadLibrary , GetProcAddress allows a program to access any function in any library
SetWindoHook: custom way to receive keyboard input
RegisterHotKey:
important Windows DLLs: 
    kernel32.dll: core functionalities. eg: access and manipulatation of memory, files, hardware.
    Advapi32.dll: advanced core Windows components. eg: Service, Registry
    User32: UI, user actions
    Gdi32: dispaly Graphics
    Ntdll: not imported directly but by kernel32. access to window kernel.eg: hiding functionality or manipulating of other process
    WSock32 Ws2_32 : network
    Wininet: higher level network functions. eg: FTP, HTTP,...
    Shell32: create other process
\software\Microsoft\Windows\CurrentVersion\Run
PE section (maybe vary among different compilers):
    text: only to execute all other sections store data
    rdata: import and export info (maybe in .idata or .edata) + read only data
    data: global data
    rsrc: resources
    reloc: relocation of lib files
    pdata: exception handling
how detect packed? virtual Size > raw data size
================================================
Chapter2
running a dll:
    run32dll.exe mydll.dll, #5 arg1 arg2
dlls frequently run most of their code in DLLMain(called from the DLL entry point) and because DLLMain is executed whenever the dll is loaded, you can often get information dynamically by forcing the dll to load using rundl32.Alternatively you can turn dll to exe by wiping IMAGE_FILE_DLL of PE header. while this wont run any imported functions, it will run DLLMain
installing dll as service: rundll32 my.dll, InstallService ServiceName
                           net start service name
procmon:systemcall,processexplorer: all of process+verified signatures+comparing strings,regshot,Dependencywalker
==================================================