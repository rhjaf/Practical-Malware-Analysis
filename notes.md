<<<Chapter 1>>>

Packed and obfuscated codes often inlcudes LoadLibrary and GetProcAddress
linking: Static, Dynamic, Runtime
no need to include a library in header of file: LoadLibrary , GetProcAddress, LdrGetProcAddress, LdrLoadDll
LoadLibrary , GetProcAddress allows a program to access any function in any library
SetWindoHook: custom way to receive keyboard input
RegisterHotKey:
important Windows DLLs: 
    kernel32.dll: core functionalities. eg: access and manipulatation of memory, files, hardware.
    Advapi32.dll: advanced core Windows components. eg: Service, Registry
    User32: UI, user actions
    Gdi32: dispaly Graphics
    Ntdll: not imported directly but by kernel32. access to window kernel.eg: hiding functionality or manipulating of other process
    WSock32 Ws2_32 : network
    Wininet: higher level network functions. eg: FTP, HTTP,...
    Shell32: create other process
\software\Microsoft\Windows\CurrentVersion\Run
PE section (maybe vary among different compilers):
    text: only to execute all other sections store data
    rdata: import and export info (maybe in .idata or .edata) + read only data
    data: global data
    rsrc: resources
    reloc: relocation of lib files
    pdata: exception handling
how detect packed? virtual Size > raw data size
================================================
<<<Chapter 3>>>

running a dll:
    run32dll.exe mydll.dll, #5 arg1 arg2
dlls frequently run most of their code in DLLMain(called from the DLL entry point) and because DLLMain is executed whenever the dll is loaded, you can often get information dynamically by forcing the dll to load using rundl32.Alternatively you can turn dll to exe by wiping IMAGE_FILE_DLL of PE header. while this wont run any imported functions, it will run DLLMain
installing dll as service: rundll32 my.dll, InstallService ServiceName
                           net start service name
procmon:systemcall,processexplorer: all of process+verified signatures+comparing strings,regshot,Dependencywalker
==================================================
<<<Chapter 4>>>

EAX : AX + AX , AX: AL + AH
mul 0x50 : mult EAX by 0x50 and stores EDX:EAX
div 0x75 : divides EDX:EAX by 0x75 and stores in EAX and remainder in EDX
nop = xhcg eax, eax
=================================================
<<<Chapter 5>>>

By default IDA pro doesn't include PE header or the resources section in the disassembly.
Spacebar
Ctrl + E
X
G or Ctrl + G 
In functions, the local variables are prefixed with var_ and local args are prefixed with arg_.
: Enter comment through disassembly
O change a operand as it is a reference to the memory or if it is a data number.
U: undefine functions,code or data. 
C: define raw bytes as code
D: define raw bytes as data
A: define raw bytes as ACII strings
====================================================
<<<Chapter 7>>>

Windows 32 API subsytem and Windows Native API 
Windows API:
    own names to represent c types: WORD,DWORD,Handlers,LongPointer,Callback
Speclial Files:
    Shared Files:
        \\serverName\share or \\?\serverName\share (\\?\ means to tells OS to disable string parsing to allow to access longer filenames)
    File access via Namespace:
        lowest namespace is NT namespace : access to all devices and namespaces exist wthin the NT namespace==> tools to view namepsae:WinObj
        e.g: \Device\PhysicalMemory to access RAM directly
    Alternate Data Stream: normalFile.txt:Stream:$DATA ==> adding one file to another but data doesnot show up in a directory listing 
Windows Registry:
    RootKey or Hive or HKEY: HKLM,HKCU,HKEY_CLASSES_ROOT,HKEY_CURRENT_CONFIG:hardware config,HKEY_USERS
    Subkey
    Key: containes many value entry
    Value entry: ordered pair with a name and value
    value or data:
Network APIs:
    Berekly compatible sockets that are in Windows(ws2_32.dll) and Unix
        WinSock API:
            WSAStartup() is the resource allocator and called before any function
            client:connect()==>send() & recv()
            server:socket()==>bind()==>listen()==>accept()==>send() & recv()
    WinINet API: "wininet.dll"
        Higher level to implement protcols such as HTTP, FTP, ...
When Malware is running:
    Accessing outside:
        DLL: a piece of memory that is being shared between running processes
             a malware may use a DLL to load itself into another process
             DllMain() is the main entry point, is called whenever we notify a DLL.
        Process:
            each process manages its own resources. But process can share memory addresses. The addresses are the same,but the physical memory that stores the data is not the same.
            CreateProcess(): one of its parameters is STARTUPINFO struct that includes a handle to the standard input, standard out, and standard error streams for the process.
        Threads:
            Threads within a process all share the same meory, but each has its own processor registers and stack. 
            Thred Context: Before an OS switches between threads, all values in CPU are saved in a structure called Thread Context.
            CreateThread(): specifies a start address of start function.
            Fibers: Microsoft uses Fibers that are managed by a thread and they share a single thread context
        Interprocess-thread coordination with mutexes:
            WaitForSingleObject(), ReleaseMutex()
        Services:
            a code that is runned and scheduled by Windows service manager
            They ususally run as SYSTEM or another privileged account
            #net start: but only running services.
            OpenSCManager(): returns a handle to athe service control manager.
            Service types:
                WIN32_SHARE_PROCESS:  combines servel different service codes inside a single DLL ==> svchost.exe
                WIN32_OWN_PROCESS
                KERNEL_DRIVER: loading code into kernel
            HKLM\SYSTEM\CurrentControlSet\Services
            #SC
        COM(Component Object Model): an interface standard that is for diffrent softwar components to call each other's code
            works with any programming language
            client-server framework
            some COM objects are provided by Microsof
            OIeInitialize() or CoInitializeEx()  before calling any other COM library functions.
            COM objects are access by GUID ==> class identifiers(CLSID) + interface identifiers(IIDs)
            OS uses the information in the registry to determine which file contains the requested COM:
                HKLM\SOFTWARE\Classes\CLSID
                HKCU\SOFTWARE\Classes\CLSID
Native API:
    There is a lot of functionality that is not exposed in Windows32 API.
    some NAP calls can be used to get information about the system,process,threads,handlers,...:
        NtQuerySystemInformation, NtQueryInformationProcess, NtQueryInformationThread, NtQueryInformationFile, NtQueryInformationKey
        NtContinue(): return from an excetion
    The subsyste, in the PE header indicates if a program is a native application

## ff

![](https://raw.githubusercontent.com/rhjaf/Practical-Malware-Analysis/main/pic.png)
> Native API